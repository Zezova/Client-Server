***Прочитать про клиент-серверную архитектуру***

Термин «клиент-серверная архитектура» – сборное понятие, состоящее из двух взаимодополняющих компонентов: сер-вера и, собственно, клиента.
~Клиент~ – локальный компьютер на стороне виртуального пользователя, который выполняет отправку запроса к серверу для возможности предоставления данных или выполнения определенной группы системных действий.
~Сервер~ – очень мощный компьютер или специальное системное оборудование, которое предназначается для разреше-ния определенного круга задач по процессу выполнения программных кодов. Он выполняет работы сервисного обслу-живания по клиентским запросам, предоставляет пользователям доступ к определенным системным ресурсам, сохраняет данные или БД.
Особенности такой модели заключаются в том, что пользователь отправляет определенный запрос на сервер, где тот системно обрабатывается и конечный результат отсылается клиенту. В возможности сервера входит одновременное обслуживание сразу нескольких клиентов.
Если одновременно поступает более одного запроса, то такие запросы устанавливаются в определенную очередь и сер-вером выполняются по очереди. Порой запросы могут иметь свои собственные приоритеты. Часть запросов с более вы-сокими приоритетами будут постоянно выполняться в первоочередном порядке!
Параметры, которые могут реализоваться на стороне сервера:
1.	Хранение, защита и доступ к данным;
2.	Работа с поступающими клиентскими запросами;
3.	Процесс отправки ответа клиенту.
Параметры, которые могут реализоваться на стороне клиента:
1.	Площадка по предоставлению пользовательского графического интерфейса;
2.	Формулировка запроса к серверу и его последующая отправка;
3.	Получение итогов запроса и отправка дополнительной группы команд (запросы на добавление, обновление инфор-мации, удаление группы данных).
Архитектура системы клиент-сервер формулирует принципы виртуального общения между локальными компьютерами, а все правила и принципы взаимодействия находятся внутри протокола.
Сетевой протокол – это особый набор правил, на основании которого выполняется точное взаимодействие между ком-пьютерами внутри виртуальной сети.
__________
***Что такое HTTP и HTTPS***

~HTTP~ (от англ. HyperText Transfer Protocol — протокол передачи гипертекста) — это прикладной протокол передачи данных в сети. На текущий момент используется для получения информации с веб-сайтов. Протокол HTTP основан на использовании технологии «кли-ент-сервер»: клиент, отправляющий запрос, является инициатором соединения; сервер, получающий запрос, выполняет его и отправля-ет клиенту результат.
передаваемые по протоколу HTTP данные не защищены, HTTPS обеспечивает конфиденциальность информации путем ее шифрова-ния;
HTTP использует порт 80.
~HTTPS~ (от англ. HyperText Transfer Protocol Secure — безопасный протокол передачи ги-пертекста) — это расширение протокола HTTP, поддерживающее шифрование посред-ством криптографических протоколов SSL и TLS.
HTTPS не является отдельным протоколом передачи данных, а представляет собой рас-ширение протокола HTTP с надстройкой шиф-рования;
HTTPs использует порт 443.
__________
***HTTP методы***

~Метод HTTP~ (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, ука-зывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, запи-санное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.
Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус 501 (Not Implemented). Если серверу метод изве-стен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом 405 (Method Not Allowed). В обоих случаях серверу следует включить в сообщение ответа заголовок Allow со списком поддерживаемых методов.
Кроме методов GET и HEAD, часто применяется метод POST.

---OPTIONS	Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.
Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.
Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «*». Запросы «OPTIONS * HTTP/1.1» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.
Результат выполнения этого метода не кэшируется.
---GET	Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.
Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:
GET /path/resource?param1=value1&param2=value2 HTTP/1.1
Согласно стандарту HTTP, запросы типа GET считаются идемпотентными
Кроме обычного метода GET, различают ещё
•	Условный GET — содержит заголовки If-Modified-Since, If-Match, If-Range и подобные;
•	Частичный GET — содержит в запросе Range.
Порядок выполнения подобных запросов определён стандартами отдельно.
---HEAD	Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.
Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.
---POST	Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер.
В отличие от метода GET, метод POST не считается идемпотентным, то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).
При результате выполнения 200 (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location.
Сообщение ответа сервера на выполнение метода POST не кэшируется.
---PUT	Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус 201 (Created). Если же ресурс был изменён, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или недопустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).
Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.
Сообщения ответов сервера на метод PUT не кэшируются.
---PATCH	Аналогично PUT, но применяется только к фрагменту ресурса.
---DELETE	Удаляет указанный ресурс.
---TRACE	Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.
---CONNECT	Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.
__________
***HTTP статус коды сервера***

1xx: Informational (информационные)
В этот класс выделены коды, информирующие о процессе передачи. При работе через протокол версии 1.0 сообщения с такими кодами должны игнорироваться. В версии 1.1 клиент должен быть готов принять этот класс сообщений как обычный ответ, но серверу отправлять что-либо не нужно. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.
100	Continue
«продолжай»	сервер удовлетворён начальными сведениями о запросе, клиент может продолжать пересылать заголовки. Появился в HTTP/1.1
101	Switching Protocols
«переключение протоколов»	сервер выполняет требование клиента и переключает протоколы в соответствии с указанием, данным в поле заголовка Upgrade. Сервер отправляет заголовок ответа Upgrade, указывая протокол, на который он переключился. Появился в HTTP/1.1
102	Processing
«идёт обработка»	запрос принят, но на его обработку понадобится длительное время. Используется сервером, чтобы клиент не разорвал соединение из-за превышения времени ожидания. Клиент при получении такого ответа должен сбросить таймер и дожидаться следующей команды в обычном режиме. Появился в WebDAV

103	Early Hints
«ранняя метаинформация»	используется для раннего возврата части заголовков, когда заголовки полного ответа не могут быть быстро сформированы
2xx: Success (успешно)
Сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса сервер может ещё передать заголовки и тело сообщения.
200	OK
«хорошо»	успешный запрос. Если клиентом были запрошены какие-либо данные, то они находятся в заголовке и/или теле сообщения. Появился в HTTP/1.0
201	Created
«создано»	в результате успешного выполнения запроса был создан новый ресурс. Сервер может указать адреса (их может быть несколько) созданного ресурса в теле ответа, при этом предпочтительный адрес указывается в заголовке Location. Серверу рекомендуется указывать в теле ответа характеристики созданного ресурса и его адреса, формат тела ответа определяется заголовком Content-Type. При обработке запроса новый ресурс должен быть создан до отправки ответа клиенту, иначе следует использовать ответ с кодом 202. Появился в HTTP/1.0
202	Accepted
«принято»	запрос был принят на обработку, но она не завершена. Клиенту не обязательно дожидаться окончательной передачи сообщения, так как может быть начат очень долгий процесс. Появился в HTTP/1.0
203	Non-Authoritative Information
«информация не авторитетна»	аналогично ответу 200, но в этом случае передаваемая информация была взята не из первичного источника (резервной копии, другого сервера и т. д.) и поэтому может быть неактуальной. Появился в HTTP/1.1
204	No Content
«нет содержимого»	сервер успешно обработал запрос, но в ответе были переданы только заголовки без тела сообщения. Клиент не должен обновлять содержимое документа, но может применить к нему полученные метаданные. Появился в HTTP/1.0

205	Reset Content
«сбросить содержимое»	сервер обязывает клиента сбросить введённые пользователем данные. Тела сообщения сервер при этом не передаёт и документ обновлять не обязательно. Появился в HTTP/1.1
206	Partial Content
«частичное содержимое»	сервер удачно выполнил частичный GET-запрос, возвратив только часть сообщения. В заголовке Content-Range сервер указывает байтовые диапазоны содержимого. Особое внимание при работе с подобными ответами следует уделить кэшированию. Появился в HTTP/1.1
207	Multi-Status
«многостатусный»	сервер передаёт результаты выполнения сразу нескольких независимых операций. Они помещаются в само тело сообщения в виде XML-документа с объектом multistatus. Не рекомендуется размещать в этом объекте статусы из серии 1xx из-за бессмысленности и избыточности. Появился в WebDAV

208	Already Reported
«уже сообщалось»	члены привязки DAV уже были перечислены в предыдущей части (multistatus) ответа и не включаются снова
226	IM Used
«использовано IM»	заголовок A-IM от клиента был успешно принят и сервер возвращает содержимое с учётом указанных параметров. Введено в RFC 3229 для дополнения протокола HTTP поддержкой дельта-кодирования

3xx: Redirection (перенаправление)
Коды этого класса сообщают клиенту, что для успешного выполнения операции необходимо сделать другой запрос, как правило, по другому URI. Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям. Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.
По последним стандартам клиент может производить перенаправление без запроса пользователя только если второй ресурс будет запрашиваться методом GET или HEAD. В предыдущих спецификациях говорилось, что для избежания круговых переходов пользователя следует спрашивать после 5-го подряд перенаправления. При всех перенаправлениях, если метод запроса был не HEAD, то в тело ответа следует включить короткое гипертекстовое сообщение с целевым адресом, чтобы в случае ошибки пользователь смог сам произвести переход.
Разработчики HTTP отмечают, что многие клиенты при перенаправлениях с кодами 301 и 302 ошибочно применяют метод GET ко второму ресурсу, несмотря на то, что к первому запрос был с иным методом (чаще всего PUT). Чтобы избежать недоразумений, в версии HTTP/1.1 были введены коды 303 и 307 и их рекомендовано использовать вместо 302. Изменять метод нужно только если сервер ответил 303. В остальных случаях следующий запрос производить с исходным методом.
300	Multiple Choices
«множество выборов»	по указанному URI существует несколько вариантов предоставления ресурса по типу MIME, по языку или по другим характеристикам. Сервер передаёт с сообщением список альтернатив, давая возможность сделать выбор клиенту автоматически или пользователю. Появился в HTTP/1.0
301	Moved Permanently
«перемещено навсегда»	запрошенный документ был окончательно перенесен на новый URI, указанный в поле Location заголовка. Некоторые клиенты некорректно ведут себя при обработке данного кода. Появился в HTTP/1.0
302	Moved Temporarily Found
«перемещено временно»
«найдено»	запрошенный документ временно доступен по другому URI, указанному в заголовке в поле Location. Этот код может быть использован, например, при управляемом сервером согласовании содержимого. Некоторые клиенты некорректно ведут себя при обработке данного кода. Введено в HTTP/1.0
303	See Other
«смотреть другое»	документ по запрошенному URI нужно запросить по адресу в поле Location заголовка с использованием метода GET несмотря даже на то, что первый запрашивался иным методом. Этот код был введён вместе с кодом 307 для избежания неоднозначности, чтобы сервер был уверен, что следующий ресурс будет запрошен методом GET. Например, на веб-странице есть поле ввода текста для быстрого перехода и поиска. После ввода данных браузер делает запрос методом POST, включая в тело сообщения введённый текст. Если обнаружен документ с введённым названием, то сервер отвечает кодом 303, указав в заголовке Location его постоянный адрес. Тогда браузер гарантировано его запросит методом GET для получения содержимого. В противном случае сервер просто вернёт клиенту страницу с результатами поиска. Введено в HTTP/1.1
304	Not Modified
«не изменялось»	сервер возвращает такой код, если клиент запросил документ методом GET, использовал заголовок If-Modified-Since или If-None-Match и документ не изменился с указанного момента. При этом сообщение сервера не должно содержать тела. Появился в HTTP/1.0
305	Use Proxy
«использовать прокси»	запрос к запрашиваемому ресурсу должен осуществляться через прокси-сервер, URI которого указан в поле Location заголовка. Данный код ответа могут использовать только исходные HTTP-сервера (не прокси). Введено в HTTP/1.1
306	зарезервировано	код использовался только в ранних спецификациях	использовавшийся в ранних версиях спецификации код ответа, в настоящий момент зарезервирован. Упомянут в RFC 2616 (обновление HTTP/1.1). Согласно ранним наброскам, код означал Switch Proxy, указывая клиенту сменить используемый прокси-сервер на указанный сервером в заголовке ответа
307	Temporary Redirect
«временное перенаправление»	запрашиваемый ресурс на короткое время доступен по другому URI, указанный в поле Location заголовка. Метод запроса (GET/POST) менять не разрешается. Например, POST-запрос должен быть отправлен по новому URI тем же методом POST. Этот код был введён вместе с 303-м вместо 302-го для избежания неоднозначности. Введено в RFC 2616 (обновление HTTP/1.1)

308	Permanent Redirect
«постоянное перенаправление»	запрашиваемый ресурс был окончательно перенесен на новый URI, указанный в поле Location заголовка. Метод запроса (GET/POST) менять не разрешается. Например, POST-запрос должен быть отправлен по новому URI тем же методом POST. Этот код был введён вместо 301-го для избежания неоднозначности. Введено в RFC 7238 (RFC 7538)

4xx: Client Error (ошибка клиента)
Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.
400	Bad Request
«неправильный, некорректный запрос»	сервер обнаружил в запросе клиента синтаксическую ошибку. Появился в HTTP/1.0
401	Unauthorized
«не авторизован (не представился)»	для доступа к запрашиваемому ресурсу требуется аутентификация. В заголовке ответ должен содержать поле WWW-Authenticate с перечнем условий аутентификации. Иными словами, для доступа к запрашиваемому ресурсу клиент должен представиться, послав запрос, включив при этом в заголовок сообщения поле Authorization с требуемыми для аутентификации данными. Если запрос уже включает данные для авторизации, ответ 401 означает, что в авторизации с ними отказано
402	Payment Required
«необходима оплата»	предполагается использовать в будущем[когда?]. В настоящий момент[когда?] не используется. Этот код предусмотрен для платных пользовательских сервисов, а не для хостинговых компаний. Имеется в виду, что эта ошибка не будет выдана хостинговым провайдером в случае просроченной оплаты его услуг. Зарезервирован, начиная с HTTP/1.1
403	Forbidden
«запрещено (не уполномочен)»	сервер понял запрос, но он отказывается его выполнять из-за ограничений в доступе для клиента к указанному ресурсу. Иными словами, клиент не уполномочен совершать операции с запрошенным ресурсом. Если для доступа к ресурсу требуется аутентификация средствами HTTP, то сервер вернёт ответ 401, или 407 при использовании прокси. В противном случае ограничения были заданы администратором сервера или разработчиком веб-приложения и могут быть любыми в зависимости от возможностей используемого программного обеспечения. В любом случае серверу следует сообщить причины отказа в обработке запроса. Наиболее вероятными причинами ограничения может послужить попытка доступа к системным ресурсам веб-сервера (например, файлам .htaccess или .htpasswd) или к файлам, доступ к которым был закрыт с помощью конфигурационных файлов, требование аутентификации не средствами HTTP, например, для доступа к системе управления содержимым или разделу для зарегистрированных пользователей либо сервер не удовлетворён IP-адресом клиента, например, при блокировках. Появился в HTTP/1.0
404	Not Found
«не найдено»	самая распространённая ошибка при пользовании Интернетом, основная причина — ошибка в написании адреса Web-страницы. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URL. Если серверу известно, что по этому адресу был документ, то ему желательно использовать код 410. Ответ 404 может использоваться вместо 403, если требуется тщательно скрыть от посторонних глаз определённые ресурсы. Появился в HTTP/1.0
405	Method Not Allowed
«метод не поддерживается»	указанный клиентом метод нельзя применить к текущему ресурсу. В ответе сервер должен указать доступные методы в заголовке Allow, разделив их запятой. Эту ошибку сервер должен возвращать, если метод ему известен, но он не применим именно к указанному в запросе ресурсу, если же указанный метод не применим на всём сервере, то клиенту нужно вернуть код 501 (Not Implemented). Появился в HTTP/1.1
406	Not Acceptable
«неприемлемо»	запрошенный URI не может удовлетворить переданным в заголовке характеристикам. Если метод был не HEAD, то сервер должен вернуть список допустимых характеристик для данного ресурса. Появился в HTTP/1.1
407	Proxy Authentication Required
«необходима аутентификация прокси»	ответ аналогичен коду 401 за исключением того, что аутентификация производится для прокси-сервера. Механизм аналогичен идентификации на исходном сервере. Появился в HTTP/1.1
408	Request Timeout
«истекло время ожидания»	время ожидания сервером передачи от клиента истекло. Клиент может повторить аналогичный предыдущему запрос в любое время. Например, такая ситуация может возникнуть при загрузке на сервер объёмного файла методом POST или PUT. В какой-то момент передачи источник данных перестал отвечать, например, из-за повреждения компакт-диска или потери связи с другим компьютером в локальной сети. Пока клиент ничего не передаёт, ожидая от него ответа, соединение с сервером держится. Через некоторое время сервер может закрыть соединение со своей стороны, чтобы дать возможность другим клиентам сделать запрос. Этот ответ не возвращается, когда клиент принудительно остановил передачу по команде пользователя или соединение прервалось по каким-то иным причинам, так как ответ уже послать невозможно. Появился в HTTP/1.1
409	Conflict
«конфликт»	запрос не может быть выполнен из-за конфликтного обращения к ресурсу. Такое возможно, например, когда два клиента пытаются изменить ресурс с помощью метода PUT. Появился в HTTP/1.1
410	Gone
«удалён»	такой ответ сервер посылает, если ресурс раньше был по указанному URL, но был удалён и теперь недоступен. Серверу в этом случае неизвестно и местоположение альтернативного документа (например копии). Появился в HTTP/1.1
411	Length Required
«необходима длина»	для указанного ресурса клиент должен указать Content-Length в заголовке запроса. Без указания этого поля не стоит делать повторную попытку запроса к серверу по данному URI. Такой ответ естественен для запросов типа POST и PUT. Например, если по указанному URI производится загрузка файлов, а на сервере стоит ограничение на их объём. Тогда разумней будет проверить в самом начале заголовок Content-Length и сразу отказать в загрузке, чем провоцировать бессмысленную нагрузку, разрывая соединение, когда клиент действительно пришлёт слишком объёмное сообщение. Появился в HTTP/1.1
412	Precondition Failed
«условие ложно»	возвращается, если ни одно из условных полей заголовка (If-Match и др., см. RFC 7232) запроса не было выполнено. Появился в HTTP/1.1

413	Payload Too Large
«полезная нагрузка слишком велика»	возвращается в случае, если сервер отказывается обработать запрос по причине слишком большого размера тела запроса. Сервер может закрыть соединение, чтобы прекратить дальнейшую передачу запроса. Если проблема временная, то рекомендуется в ответ сервера включить заголовок Retry-After с указанием времени, по истечении которого можно повторить аналогичный запрос. Появился в HTTP/1.1. Ранее назывался «Request Entity Too Large»
414	URI Too Long
«URI слишком длинный»	сервер не может обработать запрос из-за слишком длинного указанного URI. Такую ошибку можно спровоцировать, например, когда клиент пытается передать длинные параметры через метод GET, а не POST. Появился в HTTP/1.1. Ранее назывался «Request-URI Too Long»
415	Unsupported Media Type
«неподдерживаемый тип данных»	по каким-то причинам сервер отказывается работать с указанным типом данных при данном методе. Появился в HTTP/1.1
416	Range Not Satisfiable
«диапазон не достижим»	в поле Range заголовка запроса был указан диапазон за пределами ресурса и отсутствует поле If-Range. Если клиент передал байтовый диапазон, то сервер может вернуть реальный размер в поле Content-Range заголовка. Данный ответ не следует использовать при передаче типа multipart/byterange. Введено в RFC 2616 (обновление HTTP/1.1). Ранее назывался «Requested Range Not Satisfiable»

417	Expectation Failed
«ожидание не удалось»	по каким-то причинам сервер не может удовлетворить значению поля Expect заголовка запроса. Введено в RFC 2616 (обновление HTTP/1.1)

418	I’m a teapot
«я — чайник»	Этот код был введен в 1998 году как одна из традиционных первоапрельских шуток IETF в RFC 2324, Hyper Text Coffee Pot Control Protocol. Не ожидается, что данный код будет поддерживаться реальными серверами
419	Authentication Timeout (not in RFC 2616)
«обычно ошибка проверки CSRF»	Этого кода нет в RFC 2616, используется в качестве альтернативы коду 401, которые прошли проверку подлинности, но лишены доступа к определенным ресурсам сервера. Обычно код отдается, если CSRF-токен устарел или оказался некорректным
421	Misdirected Request
«неверный запрос»	запрос был перенаправлен на сервер, не способный дать ответ
422	Unprocessable Entity
«необрабатываемый экземпляр»	сервер успешно принял запрос, может работать с указанным видом данных (например, в теле запроса находится XML-документ, имеющий верный синтаксис), однако имеется какая-то логическая ошибка, из-за которой невозможно произвести операцию над ресурсом. Введено в WebDAV
423	Locked
«заблокировано»	целевой ресурс из запроса заблокирован от применения к нему указанного метода. Введено в WebDAV

424	Failed Dependency
«невыполненная зависимость»	реализация текущего запроса может зависеть от успешности выполнения другой операции. Если она не выполнена и из-за этого нельзя выполнить текущий запрос, то сервер вернёт этот код. Введено в WebDAV
425	Too Early
«слишком рано»	сервер не готов принять риски обработки "ранней информации". Введено в RFC 8470 для защиты от атак повторения при использовании 0-RTT в TLS 1.3

426	Upgrade Required
«необходимо обновление»	сервер указывает клиенту на необходимость обновить протокол. Заголовок ответа должен содержать правильно сформированные поля Upgrade и Connection. Введено в RFC 2817 для возможности перехода к TLS посредством HTTP

428	Precondition Required
«необходимо предусловие»	сервер указывает клиенту на необходимость использования в запросе заголовков условий, наподобие If-Match. Введено в черновике стандарта RFC 6585

429	Too Many Requests
«слишком много запросов»	клиент попытался отправить слишком много запросов за короткое время, что может указывать, например, на попытку DDoS-атаки. Может сопровождаться заголовком Retry-After, указывающим, через какое время можно повторить запрос. Введено в черновике стандарта RFC 6585

431	Request Header Fields Too Large
«поля заголовка запроса слишком большие»	Превышена допустимая длина заголовков. Сервер не обязан отвечать этим кодом, вместо этого он может просто сбросить соединение. Введено в черновике стандарта RFC 6585

434	Requested host unavailable	«запрашиваемый адрес недоступен»	
449	Retry With
«повторить с»	возвращается сервером, если для обработки запроса от клиента поступило недостаточно информации. При этом в заголовок ответа помещается поле Ms-Echo-Request. Введено корпорацией Microsoft для WebDAV. В настоящий момент[когда?] используется как минимум программой Microsoft Money

451	Unavailable For Legal Reasons
«недоступно по юридическим причинам»	доступ к ресурсу закрыт по юридическим причинам, например, по требованию органов государственной власти или по требованию правообладателя в случае нарушения авторских прав. Введено в черновике IETF за авторством Google[12], при этом код ошибки является отсылкой к роману Рэя Брэдбери «451 градус по Фаренгейту». Был добавлен в стандарт 21 декабря 2015 года

499	Client Closed Request
«клиент закрыл соединение»	нестандартный код, предложенный и используемый nginx для случаев, когда клиент закрыл соединение, пока nginx обрабатывал запрос

5xx: Server Error (ошибка сервера)
Коды 5xx выделены под случаи необработанных исключений при выполнении операций на стороне сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.
500	Internal Server Error 
«внутренняя ошибка сервера»	любая внутренняя ошибка сервера, которая не входит в рамки остальных ошибок класса. Появился в HTTP/1.0
501	Not Implemented 
«не реализовано»	сервер не поддерживает возможностей, необходимых для обработки запроса. Типичный ответ для случаев, когда сервер не понимает указанный в запросе метод. Если же метод серверу известен, но он не применим к данному ресурсу, то нужно вернуть ответ 405. Появился в HTTP/1.0

502	Bad Gateway 
«плохой, ошибочный шлюз»	сервер, выступая в роли шлюза или прокси-сервера, получил недействительное ответное сообщение от вышестоящего сервера. Появился в HTTP/1.0
503	Service Unavailable 
«сервис недоступен»	сервер временно не имеет возможности обрабатывать запросы по техническим причинам (обслуживание, перегрузка и прочее). В поле Retry-After заголовка сервер может указать время, через которое клиенту рекомендуется повторить запрос. Хотя во время перегрузки очевидным кажется сразу разрывать соединение, эффективней может оказаться установка большого значения поля Retry-After для уменьшения частоты избыточных запросов. Появился в HTTP/1.0
504	Gateway Timeout 
«шлюз не отвечает»	сервер в роли шлюза или прокси-сервера не дождался ответа от вышестоящего сервера для завершения текущего запроса. Появился в HTTP/1.1
505	HTTP Version Not Supported 
«версия HTTP не поддерживается»	сервер не поддерживает или отказывается поддерживать указанную в запросе версию протокола HTTP. Появился в HTTP/1.1
506	Variant Also Negotiates
«вариант тоже проводит согласование»	в результате ошибочной конфигурации выбранный вариант указывает сам на себя, из-за чего процесс связывания прерывается. Экспериментальное. Введено в RFC 2295 для дополнения протокола HTTP технологией Transparent Content Negotiation

507	Insufficient Storage 
«переполнение хранилища»	не хватает места для выполнения текущего запроса. Проблема может быть временной. Введено в WebDAV
508	Loop Detected
«обнаружено бесконечное перенаправление»	операция отменена, т.к. сервер обнаружил бесконечный цикл при обработке запроса без ограничения глубины. Введено в WebDAV
509	Bandwidth Limit Exceeded
«исчерпана пропускная ширина канала»	используется при превышении веб-площадкой отведённого ей ограничения на потребление трафика. В данном случае владельцу площадки следует обратиться к своему хостинг-провайдеру. В настоящий момент данный код не описан ни в одном RFC и используется только модулем «bw/limited», входящим в панель управления хостингом cPanel, где и был введён

510	Not Extended 
«не расширено»	на сервере отсутствует расширение, которое желает использовать клиент. Сервер может дополнительно передать информацию о доступных ему расширениях. Введено в RFC 2774 для дополнения протокола HTTP поддержкой расширений
511	Network Authentication Required 
«требуется сетевая аутентификация»	этот ответ посылается не сервером, которому был предназначен запрос, а сервером-посредником — например, сервером провайдера — в случае, если клиент должен сначала авторизоваться в сети, например, ввести пароль для платной точки доступа к Интернету. Предполагается, что в теле ответа будет возвращена Web-форма авторизации или перенаправление на неё. Введено в черновике стандарта RFC 6585

520	Unknown Error 
«неизвестная ошибка»	возникает когда сервер CDN не смог обработать ошибку веб-сервера; нестандартный код CloudFlare

521	Web Server Is Down 
«веб-сервер не работает»	возникает когда подключения CDN отклоняются веб-сервером; нестандартный код CloudFlare

522	Connection Timed Out 
«соединение не отвечает»	возникает когда CDN не удалось подключиться к веб-серверу; нестандартный код CloudFlare

523	Origin Is Unreachable 
«источник недоступен»	возникает когда веб-сервер недостижим; нестандартный код CloudFlare

524	A Timeout Occurred 
«время ожидания истекло»	возникает при истечении тайм-аута подключения между сервером CDN и веб-сервером; нестандартный код CloudFlare

525	SSL Handshake Failed 
«квитирование SSL не удалось»	возникает при ошибке рукопожатия SSL между сервером CDN и веб-сервером; нестандартный код CloudFlare

526	Invalid SSL Certificate
«недействительный сертификат SSL»	возникает когда не удаётся подтвердить сертификат шифрования веб-сервера; нестандартный код CloudFlare
__________
***Что такое ядро браузера***

~Браузерный движок~ (англ. layout engine) — представляет собой программу, преобразующую содержимое веб-страниц (файлы HTML, XML, цифровые изображения и т. д.) и информацию о форматировании (в форматах CSS, XSL и т. д.) в интерактивное изображение форматированного содержимого на экране. Браузерный движок обычно используется в веб-браузерах (отсюда название), почтовых клиентах и других программах, нуждающихся в отображении и редактировании содержимого веб-страниц.
Какие браузеры какиие ядра используют
Blink — движок браузера Chromium, браузера Google Chrome с 28 версии, Microsoft Edge с 79 версии, Opera c 15 версии и Vivaldi. Он является ответвлением WebKit.
Gecko — открытый движок проекта Mozilla; используется в большом числе программ, основанных на коде Mozilla (браузере Firefox, почтовом клиенте Thunderbird, наборе программ SeaMonkey).
WebKit — движок для браузера Apple Safari, включенного в операционную систему Mac OS X, и браузера Google Chrome (до 2013 года). Встроен в библиотеку Qt (Начиная с Qt 5.6 признан устаревшим).
KHTML — разработан в рамках проекта KDE, используется в браузере Konqueror и послужил основой для WebKit.
__________
***Что такое API***

~API~ (МФА [ˌeɪ.piˈaɪ]; аббр. от англ. Application Programming Interface — «программный интерфейс приложения»[1]) — описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная програм-ма может взаимодействовать с другой программой. Обычно входит в описание какого-либо интернет-протокола (например, SCIM[2]), программного каркаса (фреймворка)[3] или стандарта вызовов функций операционной системы[4]. Часто реализуется отдельной программной библиотекой или сервисом операционной системы. Используется программистами при написании всевозможных приложений.
Проще говоря, это набор компонентов, с помощью которых компьютерная программа (бот или же сайт) может взаимо-действовать с другой программой (API).
__________
***Что такое ендпоинты***

~Эндпоинт~ (Endpoint - конечная точка) — это само обращение к маршруту отдельным HTTP методом. Эндпоинт вы-полняют конкретную задачу, принимают параметры и возвращают данные Клиенту.
__________
***URL (URI, URL, URN)***

~URI~ (Uniform Resource Identifier) – это строка символов, которая исполь-зуется для идентификации какого-либо ресурса по его адресу или по его име-ни, либо по тому и тому вместе.
~URL~ (Uniform Resource Locator) – это строка символов, которая используется для иденти-фикации какого-либо ресурса, но только по его адресу, по его местоположению.
URL чаще всего используется в Интернете для поиска ресурсов на сервере. URL буквально точно показывает нам, как определить ресурс, именно по его адресу. Если ввести подобный URL в строке поиска браузера, то будет осу-ществлен поиск соответствующего ресурса. И хотя URL на картинке ниже немного отлича-ются друг от друга своей структурой, есть определенный формат, как должен быть по-строен любой URL.
Любой URL состоит из нескольких компонен-тов. Протокол и хост являются обязательны-ми, все остальные - нет.
Подопытный URL выше можно прочитать как: используя протокол https обратиться к домену www.mysite.com по стандартному порту 80, в каталоге найти товар желтого цвета с иденти-фикатором 15, в браузере пользователя сразу же переместиться в область где указана цена.
~URN~ (Uniform Resource Name) – это строка символов, которая используется для идентификации какого-либо ресур-са, но только по его имени.
URN служит для обозначения уникаль-ного имени ресурса, неважно, где этот ресурс располагается в данный момент времени или вообще. Такая природа URN (независимость от адреса) позво-ляет ресурсам перемещаться с одного места на другое. URN позволяет полу-чить доступ к ресурсу по различным сетевым протоколам, обращаясь к од-ному и тому же имени.
На текущий день URN все еще считает-ся экспериментальным и не так сильно распространен, как URL, так как для полной поддержки URN требуется под-держивающая его развитая сетевая ин-фраструктура.
__________
***Идемпотентные HTTP методы***

Метод HTTP является ~идемпотентным~, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. Корректно реализо-ванные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST. Также все безопасные методы являются идемпотентными.
Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, а возвра-щаемые запросами коды статуса могут отличаться: первый вызов DELETE вернёт код 200, в то время как последующие вызовы вернут код 404. Из идемпотентности DELETE неявно следует, что разработчики не должны использовать ме-тод DELETE при реализации RESTful API с функциональностью удалить последнюю запись.
Обратите внимание, что идемпотентность метода не гарантируется сервером, и некоторые приложения могут нарушать ограничение идемпотентности.
GET /pageX HTTP/1.1 идемпотентен. Вызвавший несколько раз подряд этот запрос, клиент получит тот же результат:
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
POST /add_row HTTP/1.1 не идемпотентен; если его вызвать несколько раз, то он добавит несколько строк:
POST /add_row HTTP/1.1
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
DELETE /idX/delete HTTP/1.1 идемпотентен, даже если возвращаемый код отличается:
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
__________
***Безопасные HTTP методы***

Метод HTTP является ~безопасным~, если он не меняет состояние сервера. Другими словами, безопасный метод проводит операции "только чтение" (read-only). Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS. Все безопасные методы являются также идемпотентными, как и некоторые другие, но при этом небезопасные, такие как PUT или DELETE.
Даже если безопасные методы являются по существу "только для чтения", сервер всё равно может сменить своё состоя-ние: например, он может сохранять статистику. Что существенно, так то, когда клиент вызывает безопасный метод, то он не запрашивает никаких изменений на сервере, и поэтому не создаёт дополнительную нагрузку на сервер. Браузеры мо-гут вызывать безопасные методы, не опасаясь причинить вред серверу: это позволяет им выполнять некоторые действия, например, предварительная загрузка без риска. Поисковые роботы также полагаются на вызовы безопасных методов.
Безопасные методы не обязательно должны обрабатывать только статичные файлы; сервер может генерировать ответ "на-лету", пока скрипт, генерирующий ответ, гарантирует безопасность: он не должен вызывать внешних эффектов, та-ких как формирование заказов, отправка писем и др..
Правильная реализация безопасного метода - это ответственность серверного приложения, потому что сам веб-сервер, будь то Apache, nginx, IIS это соблюсти не сможет. В частности, приложение не должно разрешать изменение состояния сервера запросами GET.
Вызов безопасного метода, не меняющего состояния сервера:
GET /pageX.html HTTP/1.1
Вызов небезопасного метода, который может поменять состояние сервера:
POST /pageX.html HTTP/1.1 
Вызов идемпотентного, но небезопасного метода:
DELETE /idX/delete HTTP/1.1
__________
***Иденфикация, Аутентификация, Авторизация***
~Идентификация~ процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе
Скажем, пользователь хочет войти в свой аккаунт Google. Для начала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это идентификация.
Идентификация без аутентификации — это просто глупо. Потому что мало ли кто ввел существующий в системе логин! Си-стеме обязательно надо удостовериться, что этот кто-то знает еще и пароль. Но пароль могли подсмотреть или подо-брать, поэтому лучше подстраховаться и спросить что-то дополнительное, что мо-жет быть известно только данному поль-зователю: например, одноразовый код для подтверждения входа.
~Аутентификация~ процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это аутентификация.
Скорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это двухфакторная аутентификация.
Аутентификация без предварительной идентификации лишена смысла — пока система не поймет, подлинность чего же надо проверять, совершенно бессмысленно начинать проверку. Для начала надо представиться.
~Авторизация~ предоставление определенному лицу или группе лиц прав на выполнение определенных действий
После этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе — это авторизация.
А вот авторизация без идентификации и тем более аутентификации очень даже возможна. Например, в Google Документах можно публиковать документы так, чтобы они были доступны вообще кому угодно. В этом случае вы как владелец файла увидите сверху надпись, гласящую, что его читает неопознанный енот. Несмотря на то, что енот совершенно неопознанный, система его все же авторизовала — то есть выдала право прочитать этот документ.
__________
***Что такое IP***

~IP-адрес~ — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP (TCP/IP – это набор интернет-протоколов, о котором мы поговорим в дальнейших статьях). IP-адрес представля-ет собой серию из 32 двоичных бит (единиц и нулей). Так как человек невосприимчив к большому однородному ряду чисел, такому как этот 11100010101000100010101110011110 (здесь, к слову, 32 бита информации, так как 32 числа в двоичной системе), было решено разделить ряд на четыре 8-битных байта и получилась следующая последователь-ность: 11100010.10100010.00101011.10011110. Это не сильно облегчило жизнь и было решение перевести данную по-следовательность в, привычную нам, последовательность из четырёх чисел в десятичной системе, то есть 226.162.43.158. 4 разряда также называются октетами. Данный IP адрес определяется протоколом IPv4. По такой схеме адресации можно создать более 4 миллиардов IP-адресов. Максимальным возможным числом в любом октете бу-дет 255 (так как в двоичной системе это 8 единиц), а минимальным – 0.
__________
***Что такое октеты в DNS***

~Окте́т~ в информатике — восемь двоичных разрядов. В русском языке октет обычно называют байтом[1][2]. Октет может принимать 256 возможных состояний (кодов, значений, комбинаций битов (нулей и единиц)).
~DNS~ (англ. Domain Name System «система доменных имён») — компьютерная распределённая система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене (SRV-запись).
Распределённая база данных DNS поддерживается с помощью иерархии DNS-серверов, взаимодействующих по опреде-лённому протоколу.
Основой DNS является представление об иерархической структуре имени и зонах. Каждый сервер, отвечающий за имя, может передать ответственность за дальнейшую часть домена другому серверу (с административной точки зрения — другой организации или человеку), что позволяет возложить ответственность за актуальность информации на серверы различных организаций (людей), отвечающих только за «свою» часть доменного имени.
__________
***Что такое порт, сколько портов у Linux сервера***

~Порт~ (англ. port) — целое неотрицательное число, записываемое в заголовках протоколов транспортного уров-ня сетевой модели OSI (TCP, UDP, SCTP, DCCP).
Количество портов ограничено с учётом 16-битной адресации (216=65536, начало — «0»). Все порты разделены на три диапазона — общеизвестные (или системные, 0—1023), зарегистрированные (или пользовательские, 1024—49151) и динамические (или частные, 49152—65535).
__________
***Уровни OSI***

~Сетевая модель OSI~ (The Open Systems Interconnection model) — сетевая модель стека (магазина) сетевых протоколов OSI/ISO. Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.
Модель OSI была разработана в конце 1970-х годов[1] для поддержания разнообразных методов компьютерных сетей, которые в это время конкурировали за применение в крупных национальных сетевых взаимодействиях во Франции, Ве-ликобритании и США. В 1980-х годах она стала рабочим продуктом группы взаимодействия открытых си-стем Международной организации по стандартизации (ISO). Модель не смогла дать полное описание сети и не получи-ла поддержку архитекторов на заре Интернета, который впоследствии нашел отражение в менее предписываю-щем TCP/IP, в основном под руководством Инженерного совета Интернета (IETF)
Уровни:
7. Прикладной (application)
6. Представления (presentation)
5. Сеансовый (session)
4. Транспортный (transport)
3. Сетевой (network)
2. Канальный (data link)
1. Физический (physical)
__________
***Хедеры http запросов***

Accept
Accept-Charset
Accept-Encoding
Accept-Language
Accept-Ranges
Age
Allow

Alternates
Authorization
Cache-Control
Connection
Content-Base
Content-Disposition
Content-Encoding
Content-Language

Content-Length
Content-Location
Content-MD5
Content-Range
Content-Type
Content-Version
Date
Derived-From
ETag
Expect
Expires
From
Host
If-Match
If-Modified-Since
If-None-Match
If-Range
If-Unmodified-Since
Last-Modified
Link
Location

Max-Forwards
MIME-Version
Pragma
Proxy-Authenticate
Proxy-Authorization
Public
Range
Referer

Retry-After
Server
Title
TE
Trailer
Transfer-Encoding

Upgrade
URI
User-Agent

Vary
Via
Warning
WWW-Authenticate
Основные заголовки
Основные заголовки (англ. General Headers) являются основными для запросов клиента и ответов сервера. Большая часть из них являются обязательными.
Заголовки запроса
Заголовки запроса (англ. Request Headers) используются только в запросах клиента.
Referer
Полный или относительный URI ресурса, с которого клиент сделал текущий запрос. Если указан относительный, то полный определяется по запрашиваемому URI. Клиенты не должны включать в значение Referer указатель фрагмента (часть URI после символа решетки «#»). Также нельзя включать ссылки на ресурсы, не имеющие собственного URI (например, ввод адреса с клавиатуры).
Примеры:
•	Referer: http://www.example.com/ — полный URI к корню сайта.
•	Referer: http://www.example.org/send-message.php?to=support — пример с параметрами.
•	Referer: /news/2007/08/23/ — указание относительного URI.
•	Referer: http://127.0.0.1/foo/bar-rules.html — такой вариант допустим.
•	Referer: ftp://storage.example.com/archive/foo-notes.htm — переход не с HTTP-ресурса.
User-Agent
Указывает программное обеспечение клиента и его характеристики. Аналогичным ему является Server для серверов и Via для прокси.
Заголовки ответа
Заголовки ответа (англ. Response Headers) включаются только в ответы сервера.
Allow
Список поддерживаемых методов всего сервера или конкретного ресурса. Посылается сервером вместе со статусами 405 и 501, а также в ответе на метод OPTIONS.
Пример: Allow: GET, HEAD, OPTIONS
Заголовки сущности
Заголовки сущности (англ. Entity Headers) — заголовки, сопровож+ющие каждую сущность как в запросах клиента, так и в ответах сервера. Тем не менее, наличие некоторых бессмыслено в заголовках запросов (например, Expires). В отдельный класс заголовки сущности выделены для того, чтобы не путать их с заголовками запроса или заголовками ответа при пере+че множественного содержимого (multipart/*). Заголовки запроса и ответа как и основные заголовки описывают всё сообщение в целом и размещаются только в начальном блоке заголовков, в то время как заголовки сущности характеризуют содержимое каждой части в отдельности располагаясь непосредственно перед её телом.
Content-Language
Указывает один или несколько естественных языков содержимого, для носителей которых оно предназначается. Языки перечисляются через запятую, порядок значения не имеет. Если +нный заголовок опущен, то предполагается, что содержимое предназначено для людей, понимающих любой язык (или же язык вообще значения не имеет). При этом возможно, что человек не отыщет там информацию на понятном ему языке.
Обратите внимание, что в этом поле следует указывать не все используемые в документе языки, а только те, которые, по вашему мнению, понимает конечный пользователь. Например, если это страница учебника по английскому языку для русскоговорящей аудитории, то указывать следует только русский язык, так как для англоговорящих людей она не нужна. А если это страница с сообщением об ошибке на двух языках, то указывать нужно оба.
В RFC сказано, что язык содержимого можно указывать для любых медиатипов, а не только для текста. Например, если это видео, где люди говорят на английском, в котором сбоку расположено окошко с сурдопереводом на амслене, а внизу расположен перевод субтитрами на русском, то заголовок Content-Language должен иметь значение «en, ase, ru». При этом, если это видео, где герои говорят на японском, и присутствует голосовой перевод на русском, то следует указать только русский язык, так как японцам, скорее всего, будет трудно расслышать родную речь.
Заголовок Content-Language описан не только в основных спецификациях по протоколу HTTP, но и в отдельной RFC 3282 «Content Language Headers». Все названия языков регистрируются в IANA
